import { NextRequest, NextResponse } from "next/server";

/* â”€â”€ WebAI GitHub credentials from env â”€â”€ */
const GITHUB_TOKEN = process.env.GITHUB_WEBAIBOT_TOKEN!;
const GITHUB_OWNER = process.env.GITHUB_WEBAIBOT_OWNER || "webaibot";

interface FileEntry {
  path: string;
  content: string;
}

function toBase64(str: string): string {
  return Buffer.from(str, "utf-8").toString("base64");
}

async function sleep(ms: number) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

export async function POST(req: NextRequest) {
  try {
    const { repoName, files, description } = (await req.json()) as {
      repoName: string;
      files: FileEntry[];
      description?: string;
    };

    if (!repoName || !files?.length) {
      return NextResponse.json(
        { error: "repoName and files are required" },
        { status: 400 }
      );
    }

    const cleanName = repoName
      .trim()
      .toLowerCase()
      .replace(/[^a-z0-9-_.]/g, "-")
      .replace(/-+/g, "-")
      .replace(/^-|-$/g, "");

    if (!cleanName || cleanName.length < 2) {
      return NextResponse.json(
        { error: "Invalid repository name" },
        { status: 400 }
      );
    }

    const headers = {
      Authorization: `Bearer ${GITHUB_TOKEN}`,
      Accept: "application/vnd.github+json",
      "Content-Type": "application/json",
      "X-GitHub-Api-Version": "2022-11-28",
    };

    /* â”€â”€ 1. Create repository under webaibot â”€â”€ */
    const createRes = await fetch("https://api.github.com/user/repos", {
      method: "POST",
      headers,
      body: JSON.stringify({
        name: cleanName,
        description: description || "AI Bot generated by WebAI",
        private: false,
        auto_init: true, // Initialize with a README so the repo has a commit
      }),
    });

    if (!createRes.ok) {
      const err = await createRes.json();
      if (err.errors?.[0]?.message?.includes("name already exists")) {
        return NextResponse.json(
          { error: `Repository "${cleanName}" already exists on webaibot. Choose a different name.` },
          { status: 409 }
        );
      }
      return NextResponse.json(
        { error: err.message || "Failed to create repository" },
        { status: createRes.status }
      );
    }

    const repo = await createRes.json();

    // Wait for GitHub to fully initialize the repo with auto_init
    await sleep(2000);

    /* â”€â”€ 2. Get the current commit SHA (from auto_init) â”€â”€ */
    let baseSha = "";
    let baseTreeSha = "";

    for (let attempt = 0; attempt < 5; attempt++) {
      try {
        const refRes = await fetch(
          `https://api.github.com/repos/${GITHUB_OWNER}/${cleanName}/git/ref/heads/main`,
          { headers }
        );

        if (refRes.ok) {
          const refData = await refRes.json();
          baseSha = refData.object.sha;

          // Get the tree SHA from this commit
          const commitRes = await fetch(
            `https://api.github.com/repos/${GITHUB_OWNER}/${cleanName}/git/commits/${baseSha}`,
            { headers }
          );
          if (commitRes.ok) {
            const commitData = await commitRes.json();
            baseTreeSha = commitData.tree.sha;
          }
          break;
        }
      } catch {
        // Repo might not be ready yet
      }

      await sleep(1500);
    }

    if (!baseSha) {
      return NextResponse.json(
        { error: "Repository was created but not yet ready. Try again in a few seconds." },
        { status: 503 }
      );
    }

    /* â”€â”€ 3. Create blobs for each file (base64 encoded) â”€â”€ */
    const blobs: { path: string; sha: string }[] = [];

    for (const file of files) {
      const blobRes = await fetch(
        `https://api.github.com/repos/${GITHUB_OWNER}/${cleanName}/git/blobs`,
        {
          method: "POST",
          headers,
          body: JSON.stringify({
            content: toBase64(file.content),
            encoding: "base64",
          }),
        }
      );

      if (!blobRes.ok) {
        const blobErr = await blobRes.json().catch(() => ({}));
        console.error(`Blob error for ${file.path}:`, blobErr);
        throw new Error(
          `Failed to create blob for ${file.path}: ${blobErr.message || blobRes.status}`
        );
      }

      const blob = await blobRes.json();
      blobs.push({ path: file.path, sha: blob.sha });
    }

    /* â”€â”€ 4. Create tree (based on the existing tree) â”€â”€ */
    const treeRes = await fetch(
      `https://api.github.com/repos/${GITHUB_OWNER}/${cleanName}/git/trees`,
      {
        method: "POST",
        headers,
        body: JSON.stringify({
          base_tree: baseTreeSha,
          tree: blobs.map((b) => ({
            path: b.path,
            mode: "100644",
            type: "blob",
            sha: b.sha,
          })),
        }),
      }
    );

    if (!treeRes.ok) {
      const treeErr = await treeRes.json().catch(() => ({}));
      console.error("Tree error:", treeErr);
      throw new Error(`Failed to create tree: ${treeErr.message || treeRes.status}`);
    }
    const tree = await treeRes.json();

    /* â”€â”€ 5. Create commit (with parent) â”€â”€ */
    const commitRes = await fetch(
      `https://api.github.com/repos/${GITHUB_OWNER}/${cleanName}/git/commits`,
      {
        method: "POST",
        headers,
        body: JSON.stringify({
          message: "Initial commit â€” AI Bot generated by WebAI ðŸ¤–",
          tree: tree.sha,
          parents: [baseSha],
        }),
      }
    );

    if (!commitRes.ok) {
      const commitErr = await commitRes.json().catch(() => ({}));
      console.error("Commit error:", commitErr);
      throw new Error(`Failed to create commit: ${commitErr.message || commitRes.status}`);
    }
    const commit = await commitRes.json();

    /* â”€â”€ 6. Update main branch ref â”€â”€ */
    const updateRefRes = await fetch(
      `https://api.github.com/repos/${GITHUB_OWNER}/${cleanName}/git/refs/heads/main`,
      {
        method: "PATCH",
        headers,
        body: JSON.stringify({
          sha: commit.sha,
          force: true,
        }),
      }
    );

    if (!updateRefRes.ok) {
      const refErr = await updateRefRes.json().catch(() => ({}));
      console.error("Ref update error:", refErr);
      throw new Error(`Failed to update branch: ${refErr.message || updateRefRes.status}`);
    }

    return NextResponse.json({
      success: true,
      repoUrl: repo.html_url,
      repoName: repo.full_name,
      cloneUrl: repo.clone_url,
    });
  } catch (err) {
    console.error("GitHub push error:", err);
    return NextResponse.json(
      { error: err instanceof Error ? err.message : "Failed to push to GitHub" },
      { status: 500 }
    );
  }
}
